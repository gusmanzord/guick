#set( $open  = "${")
#set( $close = "}")
#set( $entityBeanName = ${util.uncapitalize($entity.name)} )
package ${project.group}.${project.name}.api.rest

import br.com.petrobras.fcorp.business.service.support.ICrudService;
import br.com.petrobras.fcorp.common.entity.IEntity;
import br.com.petrobras.fcorp.exceptionhandler.HandlerResult;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import javax.annotation.Resource;
import javax.validation.Valid;
import java.io.Serializable;

/**
 * Classe base para realizaçãod e CRUDs com SpringMVC/Restfull+JSON.
 * @param <T> Classe da Entidade cujo CRUD é realizado.
 */
public abstract class CrudController<T extends IEntity<? extends Serializable>> extends br.com.petrobras.fcorp.springmvc.support.CoreController {

    @Resource
    private ICrudService service;

    @Resource
    private br.com.petrobras.fcorp.exceptionhandler.ExceptionHandler exceptionHandler;

    private static final String DEFAULT_SORT_FIELD = "nome";
    private Class<T> entityClass;

    public DataServiceController(){
        this.entityClass = getEntityClass();
    }

    /**
     * Método que deve ser sobrescrito pelas classes filhas para informar qual a entidade será manipulada.
     * @return A classe a ser feito CRUD.
     */
    protected abstract Class<T> getEntityClass();

    @RequestMapping(value = "/new", method = RequestMethod.GET, produces = "application/json")
    @ResponseBody
    public  T create() {
        try {
            return this.entityClass.newInstance();
            // Erros aqui são irrecuperáveis, propagamos para os tratadores.
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    @RequestMapping(value = "/", method = RequestMethod.POST, produces = "application/json")
    @ResponseBody
    public ResponseMessage create(@Valid @ModelAttribute T entity, BindingResult result) {
        ResponseMessage responseMessage = new ResponseMessage();
        try {
            if (result.hasErrors()){
                responseMessage.setErrorList(result.getAllErrors());
            } else {
                service.persist(entity);
            }
            return responseMessage;
        } catch (RuntimeException ex) {
            HandlerResult handlerResult = exceptionHandler.doHandle(ex);
            if (handlerResult.isHandled()) {
                responseMessage.setExceptionMessage(handlerResult.getMessages().toString());
                return responseMessage;
            }
            throw ex;
        }
    }

    @RequestMapping(value = "/{id}/", method = RequestMethod.GET, produces = "application/json")
    public @ResponseBody T get(@PathVariable Long id) {
        return service.get( getEntityClass() , id);
    }

    @RequestMapping(value = "/{id}/", method = RequestMethod.PUT , produces = "application/json")
    @ResponseBody
    public ResponseMessage update(@PathVariable Long id , @Valid @ModelAttribute T entity, BindingResult result) {
        ResponseMessage responseMessage = new ResponseMessage();
        try {
            if (result.hasErrors()){
                responseMessage.setErrorList(result.getAllErrors());
            } else {
                service.update(entity);
            }
            return responseMessage;
        } catch (RuntimeException ex) {
            HandlerResult handlerResult = exceptionHandler.doHandle(ex);
            if (handlerResult.isHandled()) {
                responseMessage.setExceptionMessage(handlerResult.getMessages().toString());
                return responseMessage;
            }
            throw ex;
        }
    }

    @RequestMapping(value = "/{id}/", method = RequestMethod.DELETE, produces = "application/json")
    @ResponseBody
    public ResponseMessage delete(@PathVariable Long id ) {
        ResponseMessage responseMessage = new ResponseMessage();
        try {
            service.remove(service.get( getEntityClass() , id ));
            return responseMessage;
        } catch (RuntimeException ex) {
            HandlerResult handlerResult = exceptionHandler.doHandle(ex);
            if (handlerResult.isHandled()) {
                responseMessage.setExceptionMessage(handlerResult.getMessages().toString());
                return responseMessage;
            }
            throw ex;
        }
    }

}


    protected static final String EDIT_VIEW = "/edit";

    protected static final String LIST_ACTION = "/list.do";

    protected static final String DETAIL_VIEW = "/detail";

    private static final String EXCEPTION_NOT_HANDLED_BY_HANDLERMANAGER = "Exception not handled by HandlerManager. Rethrowing it.";

    private static final String EXCEPTION_HANDLED_BY_HANDLER_MANAGER = "Exception handled by HandlerManager, reloading form with error message.";

    private static final Logger LOGGER = LoggerFactory.getLogger(CrudController.class);

    @Resource
    private ICrudService service;

    private Class<T> entityClass;

    private String path;

    /**
     * Construtor padrão.
     */
    public CrudController() {
        RequestMapping a = this.getClass().getAnnotation(RequestMapping.class);
        path = a.value()[0];
        this.entityClass = getEntityClass();
        LOGGER.debug("Started Controller %s with path: %s and Entity: %s", new Object[]{this.getClass().getName(), this.path, this.entityClass});
    }

    /**
     * Método utilizado pelo Controller para preparação do formulario
     * @param model O modelo do formulario.
     */
    public abstract void onFormLoad(Model model);

    /**
     * Método que deve ser sobrescrito pelas classes filhas para informar qual a entidade será manipulada.
     * @return A classe a ser feito CRUD.
     */
    protected abstract Class<T> getEntityClass();

    /**
     * Método para implementar o caso de uso "Create" do CRUD.
     * @param model Modelo a ser injetado pelo SpringMVC
     * @return Retorna a view correspondente ao formulário de edição da entidade.
     * @throws Exception
     */
    @RequestMapping(value = "create", method = RequestMethod.GET)
    public String create(Model model) {
        LOGGER.debug("Creating entity, loading form");
        onFormLoad(model);
        try {
            model.addAttribute(this.entityClass.newInstance());
            LOGGER.debug("Entity instantiated, going to edit view.");
            return getConvetionedAbsolutePath(EDIT_VIEW);
            // Erros aqui são irrecuperáveis, propagamos para os tratadores.
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }

    }

    /**
     * Método para implementar o caso de uso "Update" do CRUD.
     * @param entity Entidade modelo com identificador  valido para obter a instancia da entidade a ser editada
     * @param model Modelo a ser injetado pelo SpringMVC
     * @return Retorna a view correspondente ao formulário de edição da entidade.
     */
    @RequestMapping(value = "edit", method = RequestMethod.GET)
    public String edit(T entity, Model model) {
        LOGGER.debug("Loading form for edit");
        onFormLoad(model);
        LOGGER.debug("Loading entity");
        model.addAttribute(getBeanName(), service.get(entityClass, entity.getId()));
        LOGGER.debug("Loading edit view");
        return getConvetionedAbsolutePath(EDIT_VIEW);
    }

    /**
     * Método que efetua as alterações para os casos de uso "Create" e "Update" do CRUD.
     * @param entity A entidade sendo alterada/criada
     * @param result Resultado da valdiação
     * @param redirectAttributes Parametro injetado pelo SpringMVC para armazenar atributos em caso de redirect
     * @param model Modelo a ser injetado pelo SpringMVC
     * @return Retorna a view correspondente a um redirect para a tela de listagem ou de volta para o formulário em caso de erros.
     */
    @RequestMapping(value = "save", method = RequestMethod.POST)
    public String save(@Valid @ModelAttribute T entity, BindingResult result, RedirectAttributes redirectAttributes, Model model) {

        if (result.hasErrors()) {
            LOGGER.debug("Errors found during form validation, reloading form.");
            onFormLoad(model);
            return getConvetionedAbsolutePath(EDIT_VIEW);
        }
        try {
            if (entity.getId() != null) {
                LOGGER.debug("Entity has and ID, doing update.");
                redirectAttributes.addFlashAttribute(MESSAGE_PARAM, "br.com.petrobras.fcorp.update.success");
                service.merge(entity);
            } else {
                LOGGER.debug("Entity does not have and ID, doing persist.");
                redirectAttributes.addFlashAttribute(MESSAGE_PARAM, "br.com.petrobras.fcorp.create.success");
                service.persist(entity);
            }
            LOGGER.debug("Redirecting to list action.");
            return redirectTo(LIST_ACTION);
        } catch (RuntimeException ex) { // SUPPRESS CHECKSTYLE Illegal Catch - Esta e uma barreira de excecao
            LOGGER.debug("Exception ocurred during save. Trying to handle it.");
            HandlerResult handlerResult = getExceptionHandler().doHandle(ex);
            if (handlerResult.isHandled()) {
                LOGGER.debug(EXCEPTION_HANDLED_BY_HANDLER_MANAGER);
                onFormLoad(model);
                model.addAttribute(MESSAGE_PARAM, handlerResult.getMessages());
                return getConvetionedAbsolutePath(EDIT_VIEW);
            }
            LOGGER.debug(EXCEPTION_NOT_HANDLED_BY_HANDLERMANAGER);
            throw ex;
        }
    }

    /**
     * Método para implementar o caso de uso "Read" do CRUD.
     * @param entity Entidade modelo com identificador da entidade a ser editada
     * @param model Modelo a ser injetado pelo SpringMVC
     * @return A view para exibição da entidade.
     */
    @RequestMapping(value = "show", method = RequestMethod.GET)
    public String show(T entity, Model model) {
        model.addAttribute(getBeanName(), service.get(entityClass, entity.getId()));
        return getConvetionedAbsolutePath(DETAIL_VIEW);
    }

    /**
     * Método para implementar o caso de uso "Delete" do CRUD.
     * @param entity Entidade modelo com identificador da entidade a ser excluida
     * @param model Modelo a ser injetado pelo SpringMVC
     * @return A view para confirmação da exclusão, detalhando a entidade.
     */
    @RequestMapping(value = "delete", method = RequestMethod.GET)
    public String prepareDelete(T entity, Model model) {
        model.addAttribute(getBeanName(), service.get(entityClass, entity.getId()));
        return getConvetionedAbsolutePath(DELETE_VIEW);
    }

    /**
     * Método que efetua a exclusão da entidade, após confirmação.
     * @param entity Entidade modelo com identificador da entidade a ser excluída
     * @param redirectAttributes Parametro injetado pelo SpringMVC para armazenar atributos em caso de redirect
     * @param model Modelo a ser injetado pelo SpringMVC
     * @return Retorna a view correspondente a um redirect para a tela de listagem.
     */
    @RequestMapping(value = "delete", method = RequestMethod.POST)
    public String delete(T entity, RedirectAttributes redirectAttributes, Model model) {
        try {
            service.remove(service.get(entityClass, entity.getId()));
            redirectAttributes.addFlashAttribute(MESSAGE_PARAM, "br.com.petrobras.fcorp.delete.success");
            return redirectTo(LIST_ACTION);

        } catch (RuntimeException ex) { // SUPPRESS CHECKSTYLE Illegal Catch - Esta e uma barreira de excecao
            LOGGER.debug("Exception ocurred during delete. Trying to handle it.");
            HandlerResult handlerResult = getExceptionHandler().doHandle(ex);
            if (handlerResult.isHandled()) {
                LOGGER.debug(EXCEPTION_HANDLED_BY_HANDLER_MANAGER);
                onFormLoad(model);
                model.addAttribute(MESSAGE_PARAM, handlerResult.getMessages());
                return prepareDelete(entity, model);
            }
            LOGGER.debug(EXCEPTION_NOT_HANDLED_BY_HANDLERMANAGER);
            throw ex;
        }
    }

    /**
     * Método utilitário para cração de strings de view com redirects.
     * @param action O caminho relativo para onde deverá ser feito o redirect.
     * @return Uma String apropriada para realização de redirects.
     */
    @Override
    protected String redirectTo(String action) {
        return super.redirectTo(getConvetionedAbsolutePath(action));
    }

    /**
     * Método utilitário para criação de Strings de view baseadas em convenções
     * @param view O nome da view desejada
     * @return Uma String com o caminho completo da view.
     */
    protected String getConvetionedAbsolutePath(String view) {
        return getConventionedBasePath() + view;
    }

    private String getConventionedBasePath() {
        return path;
    }

    private String getBeanName() {
        return StringUtils.uncapitalize(entityClass.getSimpleName());
    }

}
